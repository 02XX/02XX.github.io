import{_ as e,c as o,aA as a,o as s}from"./chunks/framework.DyPz110q.js";const u=JSON.parse('{"title":"78. 子集","description":"","frontmatter":{"title":"78. 子集","categories":"leetcode","tags":["Bit Manipulation","Array","Backtracking"],"date":"2025-02-25T00:41:42.495Z","updated":"2025-02-25T00:41:42.495Z"},"headers":[],"relativePath":"78. 子集.md","filePath":"78. 子集.md"}'),r={name:"78. 子集.md"};function n(l,t,i,c,p,d){return s(),o("div",null,t[0]||(t[0]=[a('<h2 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h2><p><a href="https://leetcode.cn/problems/subsets" target="_blank" rel="noreferrer">78. 子集</a></p><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><blockquote><p><strong>输入：</strong> nums = [1,2,3] <strong>输出：</strong>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><strong>输入：</strong> nums = [0] <strong>输出：</strong>[[],[0]]</p></blockquote><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h2 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-label="Permalink to &quot;思路&quot;">​</a></h2><h2 id="题解" tabindex="-1">题解 <a class="header-anchor" href="#题解" aria-label="Permalink to &quot;题解&quot;">​</a></h2><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span></code></pre></div>',13)]))}const h=e(r,[["render",n]]);export{u as __pageData,h as default};
